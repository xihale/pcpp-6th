---
title: "Standard Library Header Files"
---

The interface to the C++23 Standard Library consists of 107 header files, 21 of which present the C Standard Library. Starting with C++23, you simply import the named module `std` to get access to the entire Standard Library, as has been done in all examples throughout this book. There is no longer a need to explicitly import or include individual header files, except for certain non-importable header files, such as `<cassert>`. However, if your compiler does not yet support the C++23 `std` named module, then you need to import or include the appropriate header files. In that case, it's often difficult to remember which header files you need to include in your source code, so this appendix provides a brief description of the most useful functionality of each header, organized into eight categories:

- The C Standard Library
- Containers
- Algorithms, iterators, ranges, and allocators
- General utilities
- Mathematical utilities
- Exceptions
- I/O streams
- Threading support library

## THE C STANDARD LIBRARY

The C++ Standard Library includes almost the entire C Standard Library. The header files are generally the same, except for these two points:

- The header names are `<cname>` instead of `<name.h>`.
- All the names declared in the `<cname>` header files are in the `std` namespace.

:::note
You can still include `<name.h>` if you want, but that puts the names into the global namespace instead of the `std` namespace. Additionally, up until C++23, the use of `<name.h>` C Standard Library headers was deprecated. Starting with C++23, their use is no longer deprecated, but discouraged.
:::

:::note
The C Standard Library headers are not guaranteed to be importable using an `import` statement. Hence, use `#include <cname>` instead of `import <cname>;`. Of course, using `import std;` also makes everything from the C Standard Library available in the `std` namespace, except for macros such as `assert`(`)` from `<cassert>`.
:::

The following table lists all C Standard Library headers and provides a summary of their most useful functionality. Note that it's recommended to avoid using C functionality, and instead use equivalent C++ features whenever possible:

| HEADER | CONTENTS |
| --- | --- |
| <cassert> | assert(`)` macro. |
| <cctype> | Character predicates and manipulation functions, such as isspace() and `tolower()`. |
| <cerrno> | Defines errno expression, a macro to get the last error number for certain C functions. |
| <cfenv> | Supports the floating-point environment, such as floating-point exceptions, rounding, and so on. |
| <cfloat> | C-style defines related to floating-point arithmetic, such as FLT_MAX. |
| <cinttypes> | Defines a number of macros to use with the printf(), `scanf()`, and similar functions. This header also includes a few functions to work with `intmax_t`. |
| <climits> | C-style limit defines, such as INT_MAX. It is recommended to use the C++ equivalents from `<limits>` instead. |
| <clocale> | A few localization macros and functions like LC_ALL and `setlocale()`. See also the C++ equivalents in `<locale>`. |
| <cmath> | Math utilities, including trigonometric functions sqrt(), `fabs()`, and others. |
| <csetjmp> | setjmp() and `longjmp()`. Never use these in C++! |
| <csignal> | signal() and `raise()`. Avoid these in C++. |
| <cstdarg> | Macros and types for processing variable-length argument lists. |
| <cstddef> | Important constants such as NULL, and important types such as `size_t` and `byte`. |
| <cstdint> | Defines a number of standard integer types such as int8_t, `int64_t` and so on. It also includes macros specifying minimum and maximum values of those types. |
| <cstdio> | File operations, including fopen() and `fclose()`. Formatted I/O: `printf()`, `scanf()`, and family. Character I/O: `getc()`, `putc()`, and family. File positioning: `fseek()` and `ftell()`. It is recommended to use C++ streams instead. (See the section “[I/O Streams](#bapp03-sec-0010),” later in this appendix.) |
| <cstdlib> | Random numbers with rand() and `srand()` (deprecated since C++14; use the C++ `<random>` functionality instead). This header includes the `abort()` and `exit()` functions, which you should avoid; C-style memory allocation functions `calloc()`, `malloc()`, `realloc()`, and `free()`; C-style searching and sorting with `qsort()` and `bsearch()`; string to number conversions: `atof()`, `atoi()`; and a set of functions related to multibyte/wide string manipulation. |
| <cstring> | Low-level memory management functions, including memcpy() and `memset()`. This header includes C-style string functions, such as `strcpy()` and `strcmp()`. |
| <ctime> | Time-related functions, including time() and `localtime()`. |
| <cuchar> | Defines a number of Unicode-related macros, and functions like mbrtoc16(). |
| <cwchar> | Versions of string, memory, and I/O functions for wide characters. |
| <cwctype> | Versions of functions in <cctype> for wide characters: `iswspace()`, `towlower()`, and so on. |

The following C Standard Library headers have been removed since C++20:

| HEADER | CONTENTS |
| --- | --- |
| <ccomplex> | Only included <complex>. |
| <ciso646> | In C, the <iso646.h> file defines macros `and`, `or`, and so on. In C++, those are keywords, so this header was empty. |
| <cstdalign> | Alignment-related macro \_\_alignas\_is\_defined. |
| <cstdbool> | Boolean type-related macro \_\_bool\_true\_false\_are_defined. |
| <ctgmath> | Only included <complex> and `<cmath>`. |

## CONTAINERS

The definitions for the Standard Library containers can be found in 16 header files:

| HEADER | CONTENTS |
| --- | --- |
| <array> | The array class template |
| <bitset> | The bitset class template |
| <deque> | The deque class template |
| <cpp23></cpp23> <flat_map> | The `flat_map` and `flat_multimap` class templates |
| <cpp23></cpp23> <flat_set> | The `flat_set` and `flat_multiset` class templates |
| <forward\_list> | The forward_list class template |
| <list> | The list class template |
| <map> | The map and `multimap` class templates |
| <cpp23></cpp23> <mdspan> | The `mdspan` class template (technically not a container, but a multidimensional view over a contiguous sequence of elements stored somewhere else) |
| <queue> | The queue and `priority_queue` class templates |
| <set> | The set and `multiset` class templates |
| <span> | The span class template (technically not a container, but a view over a contiguous sequence of elements stored somewhere else) |
| <stack> | The stack class template |
| <unordered\_map> | The unordered_map and `unordered_multimap` class templates |
| <unordered\_set> | The unordered_set and `unordered_multiset` class templates |
| <vector> | The vector class template and the `vector<bool>` specialization |

Each of these header files contains all the definitions you need to use the specified container, including their iterators. [Chapter 18](../c18), “Standard Library Containers,” describes these containers in detail.

## ALGORITHMS, ITERATORS, RANGES, AND ALLOCATORS

The following header files define the available Standard Library algorithms, iterators, and allocators, and the ranges library:

| HEADER | CONTENTS |
| --- | --- |
| <algorithm> | Prototypes for most of the algorithms in the Standard Library, and min(), `max()`, `minmax()`, and `clamp()`. See [Chapter 20](../c20), “Mastering Standard Library Algorithms.” |
| <bit> | Defines the endian class enumeration, see [Chapter 34](../c34), “Developing Cross-Platform and Cross-Language Applications,” and provides function prototypes to perform low-level operations on bit sequences, such as `bit_ceil()`, `rotl()`, `countl_zero()`, and more, see [Chapter 16](../c16), “Overview of the C++ Standard Library.” |
| <execution> | Defines the execution policy types for use with the Standard Library algorithms. See [Chapter 20](../c20). |
| <functional> | Defines the built-in function objects, negators, binders, and adaptors. See [Chapter 19](../c19), “Function Pointers, Function Objects, and Lambda Expressions.” |
| <iterator> | Definitions of iterator_traits, iterator tags, `iterator`, `reverse_iterator`, insert iterators (such as `back_insert_iterator`), and stream iterators. See [Chapter 17](../c17), “Understanding Iterators and the Ranges Library.” |
| <memory> | Defines the default allocator and function prototypes for dealing with uninitialized memory inside containers. Also provides unique_ptr, `shared_ptr`, `weak_ptr`, `make_unique()`, and `make_shared(`), introduced in [Chapter 7](../c07), “Memory Management.” |
| <memory_resource> | Defines polymorphic allocators and memory resources. See [Chapter 25](../c25), “Customizing and Extending the Standard Library.” |
| <numeric> | Prototypes for some numerical algorithms: accumulate(), `inner_product()`, `partial_sum()`, `adjacent_difference()`, `gcd()`, `lcm()`, and a few others. See [Chapter 20](../c20). |
| <ranges> | Provides all functionality for the Ranges library. See [Chapter 17](../c17). |
| <scoped_allocator> | An allocator that can be used with nested containers such as a vector of `strings`, or a `vector` of `maps`. |

## GENERAL UTILITIES

The Standard Library contains some general-purpose utilities in several different header files:

| HEADER | CONTENTS |
| --- | --- |
| <any> | Defines the any class. See [Chapter 24](../c24), “Additional Vocabulary Types.” |
| <charconv> | Defines the chars_format enumeration, the `from_chars()` and `to_chars()` functions, and related `struct`s. See [Chapter 2](../c02), “Working with Strings and String Views.” |
| <chrono> | Defines the chrono library. See [Chapter 22](../c22), “Date and Time Utilities.” |
| <codecvt> | Provides code conversion facets for various character encodings. This header is deprecated since C++17. |
| <compare> | Provides classes and functions to support three-way comparisons. See [Chapters 1](../c01), “A Crash Course in C++ and the Standard Library,” and [9](../c09), “Mastering Classes and Objects.” |
| <concepts> | Provides standard concepts such as same_as, `convertible_to`, `integral`, `movable`, and more. See [Chapter 12](../c12), “Writing Generic Code with Templates.” |
| <cpp23></cpp23> <expected> | Defines the `expected` and `unexpected` class templates, the `bad_expected_access` exception, and the `unexpect_t` and `unexpect` tags. See [Chapter 24](../c24). |
| <filesystem> | Defines all available classes and functions to work with the filesystem. See [Chapter 13](../c13), “Demystifying C++ I/O.” |
| <format> | Provides all functionality for the format library, such as format(), `format_to()`, and so on. See [Chapter 2](../c02). |
| <initializer\_list> | Defines the initializer\_list class template. See [Chapter 1](../c01). |
| <limits> | Defines the numeric_limits class template, and specializations for most built-in types. See [Chapter 1](../c01). |
| <locale> | Defines the locale class, the `use_facet()` and `has_facet()` function templates, and the various facet families. See [Chapter 21](../c21), “String Localization and Regular Expressions.” |
| <new> | Defines the bad_alloc exception and `set_new_handler()` function. This header also defines the prototypes for all six forms of `operator new` and `operator delete`. See [Chapter 15](../c15), “Overloading C++ Operators.” |
| <optional> | Defines the optional class template. See [Chapter 1](../c01). |
| <cpp23></cpp23> <print> | Defines the `print()`, `println()`, `vprint_unicode()`, and `vprint_nonunicode()` functions. See [Chapters 1](../c01) and [2](../c02). |
| <random> | Defines the random number generation library. See [Chapter 23](../c23), “Random Number Facilities.” |
| <ratio> | Defines the ratio library to work with compile-time rational numbers. See [Chapter 22](../c22). |
| <regex> | Defines the regular expressions library. See [Chapter 21](../c21). |
| <source:location> | Provides the source:location class. See [Chapter 14](../c14), “Handling Errors.” |
| <cpp23></cpp23> <stacktrace> | Provides the `stacktrace` class. See [Chapter 14](../c14). |
| <string> | Defines the basic_string class template and the type aliases `string` and `wstring`. See [Chapter 2](../c02). |
| <string\_view> | Defines the basic\_string_view class template and the type aliases `string_view` and `wstring_view`. See [Chapter 2](../c02). |
| <system_error> | Defines error categories and error codes. |
| <tuple> | Defines the tuple class template as a generalization of the `pair` class template. See [Chapter 24](../c24). |
| <type\_traits> | Defines type traits for use with template metaprogramming. See [Chapter 26](../c26), “Advanced Templates.” |
| <typeindex> | Defines a simple wrapper for type\_info, which can be used as an index type in associative containers. |
| <typeinfo> | Defines the bad_cast and `bad_typeid` exceptions. Defines the `type_info` class, objects of which are returned by the `typeid` operator. See [Chapter 10](../c10), “Discovering Inheritance Techniques,” for details on `typeid`. |
| <utility> | Defines the pair class template and `make_pair()` (see [Chapter 1](../c01)). This header also defines utility functions such as `swap()`, `exchange()`, `move()`, `as_const()`, and more. |
| <variant> | Defines the variant class template. See [Chapter 24](../c24). |
| <version> | Provides implementation-dependent information about the C++ Standard Library that you are using, and exposes all Standard Library feature-test macros. See [Chapter 16](../c16). |

## MATHEMATICAL UTILITIES

C++ provides some facilities for numeric processing. These capabilities are not described in detail in this book; for details, consult one of the Standard Library references listed in [Appendix B](../b02), “Annotated Bibliography”:

| HEADER | CONTENTS |
| --- | --- |
| <complex> | Defines the complex class template for working with complex numbers. |
| <numbers> | Provides several mathematical constants, such as pi, `phi`, `log2e`, and more. |
| <cpp23></cpp23> <stdfloat> | Provides the `float16_t`, `float32_t`, `float64_t`, `float128_t`, and `bfloat16_t` fixed-width floating-point types. See [Chapter 1](../c01). |
| <valarray> | Defines valarray and related classes and class templates for working with mathematical vectors and matrices. |

## EXCEPTIONS

Exceptions are covered in [Chapter 14](../c14). Two header files provide most of the requisite definitions, but some exceptions for specific domains are defined in the header file for that domain:

| HEADER | CONTENTS |
| --- | --- |
| <exception> | Defines the exception and `bad_exception` classes, and the `set_terminate()` and `uncaught_exceptions()` functions. |
| <stdexcept> | Non-domain-specific exceptions not defined in <exception>. |

## I/O STREAMS

The following table lists all the header files related to I/O streams in C++. However, normally your applications only need to include `<fstream>`, `<iomanip>`, `<iostream>`, `<istream>`, `<ostream>`, and `<sstream>`. Consult [Chapter 13](../c13) for details:

| HEADER | CONTENTS |
| --- | --- |
| <fstream> | Defines the basic_filebuf, `basic_ifstream`, `basic_ofstream`, and `basic_fstream` classes. This header declares the `filebuf`, `wfilebuf`, `ifstream`, `wifstream`, `ofstream`, `wofstream`, `fstream`, and `wfstream` type aliases. |
| <iomanip> | Declares the I/O manipulators not declared elsewhere (mostly in <ios>). |
| <ios> | Defines the ios_base and `basic_ios` classes. This header declares most of the stream manipulators. You rarely have to include this header directly. |
| <iosfwd> | Forward declarations of the templates and type aliases found in the other I/O stream header files. You rarely need to include this header directly. |
| <iostream> | Declares cin, `cout`, `cerr`, `clog`, and the wide-character counterparts. Includes `<istream>`, `<ostream>`, `<streambuf>`, and `<ios>`. Note that it's not just a combination of `<istream>` and `<ostream>`. |
| <istream> | Defines the basic_istream and `basic_iostream` classes. This header declares the `istream`, `wistream`, `iostream`, and `wiostream` type aliases. |
| <ostream> | Defines the basic_ostream class. This header declares the `ostream` and `wostream` type aliases. |
| <cpp23></cpp23> <spanstream> | Defines the `basic_spanbuf`, `basic_ispanstream`, `basic_ospanstream`, and `basic_spanstream` classes. This header declares the `spanbuf`, `wspanbuf`, `ispanstream`, `wispanstream`, `ospanstream`, `wospanstream`, `spanstream`, and `wspanstream` type aliases. |
| <sstream> | Defines the basic_stringbuf, `basic_istringstream`, `basic_ostringstream`, and `basic_stringstream` classes. This header declares the `stringbuf`, `wstringbuf`, `istringstream`, `wistringstream`, `ostringstream`, `wostringstream`, `stringstream`, and `wstringstream` type aliases. |
| <streambuf> | Defines the basic_streambuf class. This header declares the type aliases `streambuf` and `wstreambuf`. You rarely have to include this header directly. |
| <strstream> | Deprecated. |
| <syncstream> | Defines all classes related to synchronized output streams, such as osyncstream and `wosyncstream`. See [Chapter 27](../c27), “Multithreaded Programming with C++.” |

## THREADING SUPPORT LIBRARY

C++ includes a threading support library, which allows you to write platform-independent multithreaded applications. See [Chapter 27](../c27) for details. The threading support library consists of the following header files:

| HEADER | CONTENTS |
| --- | --- |
| <atomic> | Defines the atomic types, atomic<T>, and atomic operations. |
| <barrier> | Defines the barrier class. |
| <condition\_variable> | Defines the condition_variable and `condition_variable_any` classes. |
| <coroutine> | Defines all functionality for writing coroutines. |
| <future> | Defines future, `promise`, `packaged_task`, and `async()`. |
| <cpp23></cpp23> <generator> | Defines the `generator` awaitable class. |
| <latch> | Defines the latch class. |
| <mutex> | Defines call\_once() and the different non-shared mutex and lock classes. |
| <semaphore> | Defines the counting_semaphore and `binary_semaphore` classes. |
| <shared\_mutex> | Defines the shared_mutex, `shared_timed_mutex`, and `shared_lock` classes. |
| <stop\_token> | Defines the stop_token, `stop_source`, and `stop_callback` classes. |
| <thread> | Defines the thread and `jthread` classes, and functions `yield()`, `get_id()`, `sleep_for()`, and `sleep_until()`. |
